{?set %encoding=utf-8 %line=wrap}
{document 
  {title Acrobatomatic Build System - generic make files and companion scripts}
  {reference 170983b}
  {author %%Sebastien DEVAUX}
  {copyright %year=2019 %holder=Sebastien Devaux / ArianeGroup SAS}
  {abstract ABS (Acrobatomatic Build System) is a set of tool mainly made of
make files to support software development. It enables complete software project
technical management: chain compilation step for build binaries and distribuable
package, fetch dependencies package, run tests, support continuous integration
automated builds, and generate documentation.}
  {keywords build, compilation, document generation, unit test, software package}
  {history
    {edition %version=2 %date=2020-03-03 
update for ABS-3.0 release: misstypo and various small error fixes.
    }
    {edition %version=1 %date=2019-01-01 %%First public issue of document}
  }
{section %title=Introduction
  {section %title=Scope
Acrobatomatic Build System (ABS) is a generic build and packaging system for
software. It supports many language and many targets. To be compatible, a
project shall match the file and directory organization ABS expects. ABS is
mainly made of a set of makefiles (GNU make to be used to run those makefiles).
It is completed by some common commands available from any (near) posix like
system (including cygwin and mingw) to handle some advance features such as
downloading dependencies, running tests, packaging and publishing builds. In
some way ABS is similar to the maven/ant couple, but has been first designed to
support C/C++ software that is not really supported by maven. Among the features
are:
  - multi language support: C/C++, java, python.
  - generation of source code skeletons from templates: C++ class, unit test
    class
  - target architecture handling (including cross compilation)
  - dependencies management
  - binaries identification and traceability
  - auto installable package generation.
  - configuration management helpers and automation for continuous integration.  

  }
  {references %title=References %id=R
{ref %id=MPM %authors=A. Oram, S. Talbott %edition=1986, O'Reilly %%Managing project with make}
{ref %id=XUnit %href=https://en.wikipedia.org/wiki/XUnit %%xUnit, software unit test frameworks familly.}
  }
  {definitions %title=Glossary
{def %entry=URL %%Uniform Resource Locator}
  }
}
{section %title=Definition
  {section %title=Features and requirements
{req %id=abs.lang.1 
  ABS shall build C/C++ executables and shared libraries}
{req %id=abs.lang.2
  ABS shall build java packages}
{req %id=abs.lang.3
  ABS shall package python software and libraries}
{req %id=abs.dep.1
  buidlscripts shall automatically fetch from remote repository all needed
dependencies to build the software}
{req %id=abs.run.1
  ABS shall enable the user to run the developed software from its workspace}
{req %id=abs.run.2
  ABS shall enable the user to run in a debugger the developed software from its
workspace}
{req %id=abs.run.3
  ABS shall enable the user to launch the unit tests from its workspace}
{req %id=abs.run.4 
  ABS shall enable the user to launch in a debugger the unit tests from its
workspace}
{req %id=abs.cm.1
  ABS shall insert in generated binaries the project's and version's
identifiers}
{req %id=abs.cm.2
  ABS shall insert in binaries the build context information (who, when, where)}
{req %id=abs.cm.3
  ABS shall insert in generated binaries the build parameters (when the project
use conditional compilation)}
{req %id=abs.cm.4
  ABS shall be compatible with continuous integration automation}
Only one build process should be used from both developer's workspace and
continuous integration tools such as jenkins to ensure consistency of builds and
coherence from various context.
{req %id=abs.arch.1 
  ABS shall support several target computing architecture (various processor and
operating systems)}
The exact list of targets, is not specified and will be adjusted over the time
according the user projects' needs. At least, it should enable build of software
targeting standard x86 PC running widely used not too old GNU/Linux operating
systems. First implementations were started using RedHat 5 and Debian 7, and is
currently used on projects targeting CentOs 7, SUSE 12, Debian 8 and Debian 9.
Most features should require only GNU/make, a shell and a few additional
commands and it should be adaptable to any system where such software is
available. Some experimental projects were successfully built with ABS on
Android (through termux) and Cygwin/MinGW.  
  }
  {section %title=Design %xref=Design
     {section %title=from make to GNU make towards generic makefile
Make is a tool developed in 1977. It was design to help software developers
build binaries from multiple source files in a more efficient way that using
a static script to chain all the require compiler call. One major improvement of
make is to be able to perform only the necessary operations to build the target
files according the current intermediate files that may already be available. In
its day to day job, the software developer only edit a few files and need to
check its change by building the new software and it is useless to compile again
unchanged source files. To enable such capability, make propose to defines rules
instead of static action sequences. A rule is defined by three properties:
  - the target file: this is the goal of the rule, the file that is expected to
    be done when applying the rule.
  - the prerequisite: the list of files that are needed to build the target
    file.
  - the transformation command: a shell command that generates the target file
    from the prerequisite files.

The rules inserted in a text file constitute a makefile, that is, a file to use
as input script for the make command. When such file is named {kw Makefile} in
the current directory, it is used as the default input by the make command.

Example: a make rule to generate concat.txt file by concatenating to text files
a.txt and b.txt
{code %language=make 
{!concat.txt: a.txt b.txt
	cat a.txt b.txt > concat.txt
!}}

Make also enable to define rules applied to file type (or more exactly on file
name extension) to define once for all one type of transformation. It also
enable to define macros, or variables to avoid duplication of definitions. 

Here is a more detailed example of makefile. It defines the transformation of
C source file to object files, use gcc as the compiler, and a final binary built
from two object files. Since there is a rule to get object file from C source
files, the target binary is finally made from the two C source files.
{code %language=make
{!CC=gcc

cmd: a.o b.o
	$(CC) -o cmd a.o b.o

.c.o:
	$(CC) -c $*.c!}}

Using this makefile, and supposing {kw a.c} and {kw b.c} are available and are
containing valid C code, invoking make will chain the required gcc command call
sequence to build the final {kw cmd} target:
{code %language=sh
{!$ make
gcc -c a.c
gcc -c b.c
gcc -o cmd a.o b.o!}}  

Then, working on the software project, if for instance only b.c is changed,
invoking make will only perform the needed operation to build the out of date
intermediate and target files:
{code %language=sh
{!$ make
gcc -c b.c
gcc -o cmd a.o b.o!}}  
As it is shown in this example, make needs to know explicitly the exact list of
at least some intermediate files to be able to determine what shall be done
exactly. To learn more about make, and how to use it to manage software project,
see document {xref MPM}.

To go really generic, we need to find a way to identify the intermediate files
just by searching for source files. Unfortunately it is not achievable using
only the classical make. Most build system relies on specific scripts, trying to
generate the makefile itself from the project parameters and existing files.
Another way to do is to use an improve make such as the GNU project's make
implementation. It provide new way to define more complex filename patterns in
rules and comes with many advanced macro that can support an automatic
definition of variable from files or many other processing. So let's improve our
previous example using GNU Make to become more generic with the help of some
project layout convention:
  - source files are in the {kw src} directory.
  - intermediate files go in the {kw obj} directory.

Here is the GNU makefile:
{code %language=make
{!TARGET=cmd
CC=gcc
SRCFILES:=$(wildcard src/*)
OBJFILES:=$(patsubst src/%.c,obj/%.o,$(SRCFILES))

$(TARGET): $(OBJFILES)
	$(CC) -o $@ $(OBJFILES)

obj/%.o: src/%.c
	$(CC) -o $@ -c $^!}}

Now, if a new source file is added in the src directory, there is no more need
to edit the makefile to ensure it will be compiled and the related object code
linked to the final target. And the only definition that is project specific is
the {kw TARGET} variable definition (1st line of the Makefile). Since GNU make
is able to include files, it is possible to store the few project specific
definition in a dedicated file, then there won't be anymore a reason to edit the
Makefile itself. 

Another interesting feature of GNU make is when the include directive is used,
it adds a virtual prerequisite to the makefile to include. Then when it is not
availalbe and there is a rule enabling its creation, the rule is first applied
and once the file is newly created, it is included. This specific feature is
used by ABS to let the ABS scripts be downloaded from a remote repository. The
projects using abs does not need to import in themself a copy of the full abs,
but only to use as the default makefile, the ABS bootstrap makefile that have
only a very few rules able to:
  - include the application specific parameters
  - download and extract the ABS packages from a remote repository.
  - include the ABS main script 

This bootstrap Makefile structure is the following:
{code %language=make
{!# include application specific parameters
include app.cfg
# include the main ABS makefile
include .abs/core/main.mk

# This rule enable to download, from a remote repository, the core ABS package providing 
# the .abs/core/main.mk makefile among others
.abs/%/main.mk:
	mkdir -p .abs
	wget $(patsubst .abs/%/main.mk,$(ABS_REPO)/abs-%.tar.gz,$@) -O - | tar xvzf - -C .abs --strip-components=1
!}}

The real bootstrap file will contain some additional rules and variables to be
able to use a local repository as well as a remote one, and to manage ABS
versions.
     }
     {section %title=Project standardized layout
To let a generic build system works, some common conventions are still needed.
The project shall have two level of directory :
  - the application level, that is in fact the root level.
  - the modules level, an application could be made of several module and each
    module is hosted in a specific subdirectory of the root directory. Of course
    a simple and small application may be composed of one single module.

At each level, that is into the root directory and into each module directory,
the ABS feature are brought by:
  - the abs bootstrap makefile named as {kw Makefile} to be selected as the
    default makefile when running the make command.
  - a configuration file, named app.mk at application level and module.mk at
    module level.

The only directories where ABS shall create files are (with {kw <prjroot>} being
your project's root directory):
  - {kw ~/.abs}: to store the local copy of ABS itself.
  - {kw <prjroot>/build}: all files generated by the build process.
  - {kw <prjroot>/dist}: stores the distribution package archives.

Those three directories, since containing only outputs of the generation process
should never be set under revision control.

Besides the output directories, the {kw app.cfg} and {kw Makefile} files, the
project's root directory shall only contains directories: one for each module.
     }
     {section %title=Modularity
The GNU make include feature shall be used to:
  - avoid any make code, rules and macro definition duplication, by using
    a common file to be included to store common definition.
  - enable project and modules configuration adaptation, by defining specific
    rules and macros into dedicated file that are included only when needed.

The bootstrap makefile includes a single main core makefile that will itself
include the current application, and module configuration, and then include the
needed sub-makefile regarding the application and module's parameters.   

ABS itself is split in several module. Each module is a set of makefile and
companion scripts handling a specific set of tasks. The ABS modules are:
  - core: ABS core features
    - application, module configuration parameters handling
    - programming language support: C/C++, java, python.
    - unit tests management.
    - operating system identification.
  - doc: document processing features
  - mstrans: matlab/simulink to SMP2 wrapping features
  - jenkins: jenkins integration helper scripts.

Inside the ABS core module, the technical service and utility features are
implemented into the following files:
  - main.mk: detects whether the current directory is the application root or
    a module directory to include the appropriate file.
  - app.mk: application level service.
     - builds all modules
     - run tests of all modules
     - build distribution packages
     - creation of new modules
     - complete build, test, packaging and package publication triggered by the
       single target {kw cint} [{req abs.cm.4}].
  - module.mk: module level service. Reads the module parameters to include the
    required specialized makefile according the module type and the specific 
    needed features and extensions requested by the module configuration.
  - module-absext.mk: defines mapping between module types and makefile to
    include name patterns
  - module-extlib.mk: external library management.
  - module-util.mk: provide additionnal features (create source files from
    template, run lua shell, display ABS variables values).

All module type specialized makefile shall provide target that are consistent
with the main targets:
  - all: default target that builds everything (unique to module.mk to avoid
    bugs on this target)
  - all-impl: implementation of the all target that builds everything. The
    target all depends of this target.
  - clean: remove all output files
  - check, test, debugcheck, debugtest: run unit tests without or with debugger.
  - run: launch the built software.

When any of the above target is not meaningful for the module or extension (for
instance {kw run} is not relevant for a documentation module), the specific ABS
scripts shall be tolerant to the use of the target anyway. That means using such
target shall not fail in this case but only report nothing has to be done. Thus
all modules, whatever the type, can be handled the same way at the highest level
and the automation of module target calling sequence just by simple recursions
is feasible. 
{fig %src=abs-class-uml.png %title=ABS interfaces and module types hierarchy}
{#
@startuml abs-class-uml.png
class Application {
	+ all()
	+ clean()
	+ dist()
	+ distinstall()
	+ test()
	+ cint()
	+ newmod()
}
class ApplicationCfg {
	+ APPNAME
	+ VERSION
	+ USELIB
	+ VPARENT
	+ VISSUE
	+ VABS
	+ ABS_REPO
}
ApplicationCfg <. Application
interface Module {
	- all()
	+ all-impl()
	+ clean()
	+ run(args)
	+ debug(args)
	+ test()
}
class ModuleCfg {
	+ MODNAME
	+ MODTYPE
	+ USEMOD
}
ModuleCfg <. Module
Application o-- "*" Module
Module <|-- native
native <|-- library
native <|-- exe
class test {
	+ test()
	+ debugtest()
	+ newtest()
}
native o-- test
Module <|-- fileset
class doc {
	+ html()
	+ pdf()
	+ release()
}
Module <|-- doc
Module <|-- jar
jar o-- junit
test <|-- junit
Module <|-- python
python o-- testpython
test <|-- testpython
class util {
	+ newclass()
	+ shell()
	+ showvar()
}
Module .> util

@enduml
#}

The above diagrams enumerates the minimal configuration parameters expected at
application and module levels. The variable index in section {xref SecVarIndex},
provides the name and description of all variables including internal variables
to be used by the module type specific makefiles.
     }
{section %title=Modules commons %xref=SecModCom
       {section %title=Host operating system and hardware identification %xref=SecArch
Many ABS features are host dependant. The first and main one is obviously the
compiler. Then an architecture identifier is used at different stages of the
build process, in particular to tag distribution archives to know by its where
such archive can be used.

The architecture identifier is made of two parts:
  - first is the operating system identifier. It is computed by the script OS.sh
    from the ABS core package. This script makes use of the {kw lsb_release}
    when available that provides Linux distribution identifier, operating system
    version identifier and few other attributes. It can also use the {kw uname}
    command that provide similar information where {kw lsb_release} is not 
    available. The final identifier, in most case, include the distribution 
    identifier and a major version number. Finer attributes may be added when 
    incompatibilities between operating system releases are discovered.
  - second is the CPU architecture name. It is provided by the {kw uname -m} 
    command.

       }
       {section %title=debug and release modes %xref=SecMode
By default, ABS manages two build mode:
  - debug: default mode for the everyday developer work.
  - release: default mode for the distribution package.

Each sub-makefile handling a specific module type shall adapt its part of the
build process according the mode. The debug mode shall provide debug information
and disable any optimization is the final targets, while the release mode shall
remove the debug information and can apply some optimizations.
       }
       {section %title=Output layout
All intermediate and output files of the build process are stored in a dedicated
directory tree. Its naming pattern starting from the project root is 
{kw build/<arch>/<mode>}, where:
  - {kw <arch>} is the operating system and architecture identifier 
    (see §{xref SecArch})
  - {kw <mode>} is the mode name (see §{xref SecMode})

From this directory, a standard unix layout is applied, and it may contain the
following subdirectories:
  - {kw bin}: executable commands.
  - {kw etc}: configuration files.
  - {kw include}: header files.
  - {kw lib}: stores libraries.
  - {kw log}: log files.
  - {kw obj}: intermediate files, any kind. It includes of course object files
    produced by the compilers, but also generated source files if needed.
  - {kw share}: shared data files, resources, documentation
  - {kw test}: output files from tests.

       }
       {section %title=Dependencies management
One preliminary prerequisite of the build process is to fetch the needed
external libraries. The needed external libraries list is defined using the
USEMOD variable at application level.

The {kw module-extlib.mk} makefile from the ABS core packages defines the rules
to download the ABS compatible packages from a distribution repository. The URL
of the repository is defined by a variable. Its default value is the primary ABS
repository. A repository list can be set. The {kw getdist.sh} script included in
the ABS core package handles the download and extract. It use the repository
list to search for the library to download by trying one by one each repository
in the list order.

Once download and extracted int the {kw build/<arch>/extlib} directory, the
makefile import.mk is included to enable the imported library to enrich the
build process to for instance:
  - fetch itself its own required external libraries.
  - enrich the make variables, for instance add specific flags to the compiler
    command.
  - provide new rules and even ABS extensions.

Then an ABS compatible library distribution shall include in its archive root
directory a file named import.mk.

The application level makefile app.mk, include a rule to generate the import.mk
file when building a distribution archive. Without specific directive, the
generation is performed accordingly to the application configuration (name,
version, and own dependencies from its own USELIB setting).

The {kw module-extlib.mk} makefile also perform some checks to detect conflicts
between dependencies. To do so, it use the GNU make text macro to check each
library is not present more than once. The steps of the checking is:
  - get the complete sorted list of external library (containing direct and
    indirect imported libraries)
  - remove the version numbers in the list.
  - build a second list by sorting (the sort function removes duplicated words).
  - if the two list are not identical, it means one entry has been removed in
    the last sort because it was present at least twice before the sort,
    revealing a dependency consistency.

This makefile also provide a {kw checkdep} target. It calls the 
{kw deptool.bash} script from the ABS core package. This script, once external
libraries have been fetched, is able to extract, merge and translate project
configuration and settings from the related {kw import.mk} files into a GraphViz
dot script that is then rendered as an image (see example in section
{xref SecDepCheck}).

       }
     }
     {section %title=C/C++ support
C/C++ module support is brought by the core ABS module. A C/C++ module shall
have only one "real" target: one library (shared object file) or one binary
(standard executable file). The C/C++ features and related makefiles are
included with the ABS core distribution, more specifically, the C/C++ features
are provided by the following makefiles:
  - modules-cheaders.mk: rules to publish headers. Related to the PUB_H module
    configuration parameters, introduced only to ease the integration of 
    existing software as an ABS managed project.
  - module-crules-var.mk: defines common variable for C/C++ handling.
  - module.crules.mk: defines rules to go from source code to final binary.
  - module-exe.mk: defines executable target for {kw exe} module type.
  - module-library.mk: defines shared object target for {kw library} module 
    type.
  - module-test.mk: provides Unit test features based on cppunit. 

For C/C++ the build process and related rules overview is the following:
  - The list of object files is derived from the list of source files (files
    from module src directory having .c or .cpp extension).
  - an object file is done from the corresponding C source file by running the
    C compiler.
  - alternatively an object file is done from the corresponding C++ source file
    by running the C++ compiler
  - the final target is made from all object file by running the linker command.

Some advanced rules are included to define dynamically dependencies to header
files directly from source and ensure all needed source files are processed
again when any header file is changed.

Additionally, there are some rule to generate intermediate source files, that
will be themselves derived as object file and complete the list of objects to
link in the final target:
  - vinfo.c or vinfo.cpp: defines a static string containing meta data about the
    application and module, such as name, version, or build option. This string
    is used by the mastol logger to print a signature of each library when the
    software is started. It enables also to use the unix {kw ident} command to
    extract the information directly from the built binary file.
  - resource C file: such file is done for each resource file found in the
    module's src/res directory. It defines a static buffer and set its value to
    the content of the corresponding resource file in src/res. This enable to
    define long static string from flat files, or any kind of resource (image,
    or any other) to be embed in the target library.

     }
     {section %title=Java support
Java is handled slightly the same way than native compilation. Where native 
compilation is a two step process, building object file from source file, then
linking all together in an executable or a library, the Java build is also a two
step process: for each java source file, a .class file is build, then all .class
files are  compressed in a .jar file.

     }
     {section %title=Python Support
Python being a programming platform relying first on an interpretor, the python
build process is more a file packaging process. The python files are copied into
the build directory tree trying to comply to what's python expects when loading
libraries.

     }
     {section %title=Unit test management
Unit test management is defined in language dedicated makefiles of the core ABS
package:
  - module-test.mk: C/C++ unit test handling using cppunit.
  - module-junit.mk: java unit test handling using JUnit.
  - module-testpython.mk: python unit test handling

Each language use its own test runner and unit test library but all should be
compliant to the xUnit general principles (see {xref XUnit}). From the ABS
perspective, all test procedure are, first eventually complied (C/C++/java),
then run sequentially. Of course, the test target has a dependency over the main
module target to ensure the software to be checked is built before running
tests. The test run progression is printed on the standard output and in a file
for further post-analysis. On test run completion a report file is generated
using the JUnit report XML format to enable processing of results with third
party tools in general and within jenkins in particular. A summary is also
printed on the standard output by XSLT processing of the XML report (see
xunit2txt.xml in ABS core package).

     }
     {section %title=Generic file set handling
The {kw fileset} module type is the ultimate generic module, but it finally
performs almost no processing, it just copy files as-is from module's src
directory to the application target directory. The only specific processing is
to grant execution to files comming from module's src/bin if any. Since those
files destination is the application's bin directory, we choose to apply the
unix general rule to store there executable files only.

     }
     {section %title=Document processing
Document processing feature is brought when using the {kw doc} module type. It
is implemented by a the dedicated ABS-doc package. Its main components are:
  - main.mk: document file processing rules
  - html directory: resource for generated html documents.
  - style.xhtml.xls: heml transformation to html format
  - tex directory: latex templates and macros
  - style.tex.xsl: heml transformation to tex format. 

This package uses external components :
  - heml processor: enables converting the document input format using XSLT
    style sheets. It is used by ABS-doc to generate both tex and html files from
    a single source heml document. 
  - plantuml: generates graphic UML diagrams from textual object specifications.
  - dia: inline export of dia diagrams to document embeddable png files.
  - doxygen: reference documentation generation from the commented source code.

     }
     {section %title=Cross compilation
ABS enable cross copmilation where cross-compilers are available. The XARCH
varaible is used to someway force the architecture identifier to the target
architecture. It also includes also some standard cross compilation
configration. Those configuration set specific value to many variable such as
CC, CPPC, etc. Those variables define the command to use for many compilation
tasks and of course needs specific value to use alternate compilers and linkers,
that are in this case the cross compilers and linkers.
     }
     {section %title=Dependencies management
       {section %title=Scope
ABS manage two kind of dependencies:
  - internal dependencies between modules. As presented earlier, an ABS
    compatible project may be composed of several modules and each module may 
    need some other modules to be built first.
  - external library dependencies. To manage external libraries (that can be
    software components built with ABS), ABS provide fetching feature and
    packaging format to automate the integration of the required external
    libraries binaries into a project workspace.

       }
       {section %title=Internal modules dependencies
A module dependency is define at module configuration level: a module requesting
other modules to be built first just have to set the required modules names into
the {kw USEMOD} variable. At generic module level rules (defined in 
{kw core/module.mk}), a explicit dependency to all sources files to a dependency
build stamp file is derived from the USEMOD definition. This enables to trigger
automatically the build of missing required modules, before processing any
source file of the currently build module. USEMOD definitions are also processed
at application wide level (see {kw core/app.mk}, to let the make command compute
the modules building order consistently with each internal dependency.  

USEMOD definition is also processed by more language and compilers specific
rules (see for instance {kw core/module-crules-*.mk}) to compute the needed
command flags to let commands retrieve the files from the dependent modules (see
for instance CFLAGS, LDFLAGS definitions).
       }
       {section %title=External library dependencies
In a similar way, to make use of an external library, the application wide
configuration file ({kw app.mk}) shall define the {kw USELIB} variable with the
names (including version number) of the needed external libraries.

The handling of the USELIB variable is mostly defined in 
{kw core/module-extlib.mk}), this sub make file contains the rules to include
a specific {kw import.mk} file that should be present in the precompiled
software package to import (see here after for more information about this
file). When this file is not founde, a rule is activated to download the package
from a remote repository. The repository root URL is defined by the 
{kw LIB_REPO} variable. Its default value is the ABS repository URL. Once
downloaded and included, the external dependency may itself have other
dependencies. Using the same rules, all dependencies of dependencies are
transitively fetched.

Then a ABS compatible library package organisation should be the following,
inspired from standard Unix file organization:
  - root directory named {kw <libname>-<version>}
    - {kw import.mk}: ABS integration file
    - {kw bin}: scripts and commands binaries.
    - {kw lib}: shared libraries and objects binaries.
    - {kw etc}: configuration files
    - {kw share}: additional shared files, documentation, ...

An ABS library package should be named according this scheme:
{kw <libname>-<version>.<arch>.tar.gz}.

The import.mk file is included to the main Makefile when invoking make to
perform a build. Then it should alter as needed the ABS make variables to
complete flags and other parameters to enable all processing commands (mainly
compilers) as well ase the USELIB variable itself to declare new dependencies.
For project managed with ABS, import.mk file is automatically generated and
inserted in the built binary package when using the dist target from application
level (then defined in the {kw core/app.mk}). However, for external project, the
import.mk is in most case easy to implement by a one line make macro call. For
a library named AAA in version VA and using itself libraries BBB and CCC in
version VB and VC, the import.mk file is:
{code %language=make
{!$(eval $(call extlib_import_template,AAA,VA,BBB-VB CCC-VC))!}} 
       }
     }
     {section %title=Extensibility %xref=absext
ABS is extensible. A pattern matching rule is defined in {kw module.mk} to let
ABS itself to download additional package (mostly set of makefiles) for some
specific module types (defined in the module configuration file {kw module.cfg}
using {kw MODTYPE} package). The {kw MODULE_TYPE_MAP} defines the assignment of
module type over ABS packages. Its initial value is defines in
{kw core/module.mk} and can be extended.

A project using ABS can itself provide its own ABS extension. ABS extension
management is handled by {kw core/module-absext.mk} that provide many helpers
rules to manage the integration of the extension in the distributable package of
the application through its embedded import.mk.
     }
     {section %title=In-line help
Master makefiles ({kw app.mk} and {kw module.mk} include a generic help target
to display some short user documentation. It is just a {kw grep} command to
display all lines starting with "## " (two sharp, one space) of all included
makefiles. To let this system display readable help messages, try to apply the
following rules while developing and maintaining all ABS' makefiles:
  - Start with a header giving a clear section break and short description of
    the scope of the makefile.
  - introduce overloadable variables definition section
  - in-line variable comment tells the role and the default value of the
    variable
  - introduce the targets section
  - in-line target comment tells the role of the target. Remember to mention
    variables expected on make invocation command line that are specifically
    used by the target.
  - limit line length to 80 characters max to keep readable even on text
    console.

Those rules are summarized by the following template:
{code %language=make %title=Documented makefile template  
{!## --------------------------------------------------------------------
## Documented makefile template 
## Short introduction of the services provided by this makefile
## --------------------------------------------------------------------
## 
## Overloadable variables :
## 
##  - VAR1: variable 1 description, default value is value1
VAR1=value1
##  - VAR2: variable 2 description, default value is value2
VAR2=value2
## 
## Targets:
##   - tgt1 A=arg: target 1 description, A argument is ...
tgt1: 
	echo "A=$(A)"
##   - tgt2 [B=arg]: target 2 description, B optionnal argument is ...
tgt2:
	echo "B=[$(B)]"!}}

Since only included makefiles are parsed for displaying help, the content
displayed depends on the module configuration. It should then only print help
about features available to the current configuration. For instance java build
service help is shown only from java modules. When the inclusion of the makefile
is dependant of the target set on make invocation, its help will not be printed
when calling only help target, unless the help target itself is added to the
include target selection. As an example, see the following extract showing
conditional inclusion of test services sub-makefiles:
{code %language=make %title=module.mk extract - test services conditional include section
{!INCTESTS:=$(findstring test,$(MAKECMDGOALS))$(findstring check,$(MAKECMDGOALS))$(findstring help,$(MAKECMDGOALS))
ifneq ($(INCTESTS),)
 ifneq ($(findstring library,$(MODTYPE))$(findstring exe,$(MODTYPE)),)
  $(info including module-test)
  include $(PRJROOT)/make/module-test.mk
 else ifeq ($(MODTYPE),jar)
  include $(PRJROOT)/make/module-junit.mk
 else ifeq ($(MODTYPE),python)
  include $(PRJROOT)/make/module-testpython.mk
 endif
endif!}}
     }
  }
  {section %title=External libraries and dependencies
Buildscripts need to have some tools available on the workstation for its own
purpose.
{table %title=Dependencies list
{tr
{th Tool/lib} {th description} {th license}
}
{?table
gcc % C compiler (default) % GPL
g++ % C++ compiler (default) % GPL 
g++ % Linker (default) % GPL 
gdb % The GNU debugger % GPL
javac % Java compiler and development kit % JDK Supplier dependent, GPL for OpenJDK   
xsltproc % libxml2's XSLT processor % MIT license   
Doxygen % Document generator % GPL  
Latex % Document processing % Latex project public license
Bourne shell % command interpreter % GPL (bash)
GNU make % make command % GPL
GNU ed % File editor % GPL
GraphViz % diagram generator % Eclipse Public License
curl % command line HTTP client % MIT/X derivate
wget % alternate HTTP client % GPL
ssh/scp % secure shell client % BSD derivate
subversion % revision control system % Apache/BSD
java % Java Runtime Environment % JRE supplier dependent, GPL for OpenJDK
GNU tar % GNU tape archive tool % GPL
valgrind % debugging and profiling tool % GPL
}
}
{note %title=about the GPL and copyleft licenses
All GPL licensed product are used as is in development environment and are not
needed to be deployed with any ABS managed project on operational target, unless
such project itself makes direct and explicit use of such product for its own
purpose. Then it is possible and allowed to develop full proprietary software
with abs. 
}
GNU make and a {em not too old} Bourne shell (bash preferred) are the only
mandatory prerequisites:
  - other tools listed above are required only for the feature they support. For
    instance a java compiler is needed only when the project managed with ABS
    includes java code.
  - for a given feature, only one tool supporting the feature is needed. For
    instance for C++ projects, one can choose gcc or clang. It is not necessary
    to have both available on your workstation. Any other C compiler can even be
    used as soon it supports the same command line flags. However some advanced
    feature may still need a particular implementation (See table below).
  - no precise version information is provided since many Linux and posix like
    system are known to be compatible. Buildscripts is daily used with various
    RedHawk/CentOS Linux versions (starting from version 6.3), Debian Linux.
    Basic features are working Cygwin, Msys2 (GNU tools for Mingw64) despite 
    quite slow. However some very particular features may be usable only from a
    few targets operating systems (for instance, obviously Linux kernel module
    support is operational only from a Linux host).

Features using specific tooling are:
{table %title=Per feature dependencies
 {tr
  {th Feature}  {th related tools}
 }
{?table
External dependencies download % curl or wget
Release note generation % curl, subversion or git
PDF document generation % latex
Document generation from source code % Doxygen
UML class diagrams generation from source code % Doxygen, xsltproc, GraphViz
Distribution archive publication % ssh/scp 
Diagram rendering % graphviz (through document processing features)
Distribution archive generation % GNU tar 
Debugging execution % gdb
Profiling execution % valgrind 
Automated configuration management % subversion, GNU ed
}
}
  }
}
{section %title=Validation plan
  {section %title=Test strategy
The dummy project named sampleprj is setup to check many ABS features:
  - the module management is checked through the several modules created in
    sampleprj.
  - C/C++ library build is checked using the ccplib module.
  - C/C++ executable build is checked using the cppexe module.
  - java package build is checked using the jmod module.
  - python software packaging is checked using the psysubpckA and pysubpckB
    modules.
  - modules include unit tests to check related test automation features.
  - document edition and generation features are checked using the _doc module.

Some common references are used in the procedures described in the next section
to identifiy file path and repository location:
  - {kw <wsroot>} is your workspace root directory
  - {kw <installpath>} is an installation path for installing built components during tests.
  }
  {section %title=Procedures and analysis
    {check %id=general %title=General functional test %xref=CheckGen
      {operation
Checkout the abs release to be tested, then go to the {kw sampleprj}
sub-directory (replace {kw X.Y.Z} by the version to test):
{code %language=sh
{!$ cd <wsroot>
$ git clone https://github.com/seeduvax/AcrobatomaticBuildSystem.git
cd AcrobatomaticBuildSystem
git checkout abs-X.Y.Z
cd sampleprj!}}
      }
      {operation
Build the sample project's install archive:
{code %language=sh
{!$ make distinstall!}}
      }
      {assert
Project is built. At the end of the process the installation archive is
available in {kw dist} directory as {kw sampleprj-0.4.Xd.<arch>-install.bin}
      }
      {operation
Install the package to the test install location {kw <installpath>}:
{code %language=sh
{!$ ./dist/sampleprj-0.4.Xd.<arch>-install.bin install <installpath>!}}
      }
      {assert
{req abs.lang.1}
The project C/C++ binaires are built and installed (from <installpath>):
  - bin/sampleprj
  - bin/sampleprj_cppexe
  - lib/libsampleprj_cpplib.so
  - lib/libsampleprj.so
      }
      {assert
{req abs.lang.2}
The project java packages are built and installed (from <installpath>):
  - lib/fr.example.sampleprj.jmod-0.4.Xe.jar
      }
      {assert
{req abs.lang.3}
The project python scripts are integrated and installed (from <installpath>):
  - bin/sampleprj_pysubpckA.sh
  - bin/sampleprj_pysubpckB.sh
  - lib/python/pysubpckA/moduleA.pyc
  - lib/python/pysubpckB/moduleB.pyc
  - lib/python/pysubpckB/pysubsub/subsub.pyc
      }
      {assert
{req abs.dep.1}
The project's dependencies are integrated and installed (from <installpath>):
  - bin/lua
  - bin/luac
  - lib/liblua.so 
      }
      {operation
Extract configuration management information from the binaries:
{code %language=sh
{!$ ident <installpath>/lib/libsampleprj*!}}
      }
      {assert
{req abs.cm.1}
{req abs.cm.2}
Configuration management data (product name, version, subversion revision, build
context) is printed on screen like in the following sample:
{code
{!<installpath>/libsampleprj_cpplib.so:
     $Attr: app.name=sampleprj $
     $Attr: app.version=0.4.2e $
     $Attr: app.revision=undef $
     $Attr: app.file=libsampleprj_cpplib.so $
     $Attr: company=eduvax $
     $Attr: copyright= $
     $Attr: build.mode=release $
     $Attr: build.opts= $
     $Attr: build.date=jeudi 2 novembre 2017, 09:59:37 (UTC+0100) $
     $Attr: build.host=tethys $
     $Attr: build.user=sdevaux $
     $Attr: build.id=null $

/home/net/m026258/temp/sampleprj-0.4/lib/libsampleprj.so:
     $Attr: app.name=sampleprj $
     $Attr: app.version=0.4.2e $
     $Attr: app.revision=undef $
     $Attr: app.file=libsampleprj.so $
     $Attr: company=eduvax $
     $Attr: copyright= $
     $Attr: build.mode=release $
     $Attr: build.opts= $
     $Attr: build.date=jeudi 2 novembre 2017, 09:59:37 (UTC+0100) $
     $Attr: build.host=tethys $
     $Attr: build.user=sdevaux $
     $Attr: build.id=null $!}}

Version numbers may change regarding the {kw sampleprj} version you are using
for the test. The build attributes (date, host, user) are related to the build
operation done in first steps of the current test procedure.
      }
    } 
    {check %id=arch %title=multi architecture support
      {req abs.arch.1}
      {operation
Run the check procedure {kw general} (see section {xref CheckGen}) from a Debian
8 x86/64 host.
      }
      {assert
All assertions from the procedure {kw general} are satisfied.
      }
      {assert
The install package file name is {kw sampleprj-0.4.Xd.Debian_8_x86_64-install.bin}.
      }
      {operation
Run the check procedure {kw general} (see section {xref CheckGen}) from
a RedHawk 7 x86/64 host.
      }
      {assert
All assertions from the procedure {kw general} are satisfied.
      }
      {assert
The install package file name is {kw sampleprj-0.4.Xd.CentOS_7_x86_64-install.bin}.
      }
    }
    {check %id=run %title=Running debugging and testing features test %xref=CheckRun
      {operation
Go to {kw <wsroot>} and checkout sampleprj-0.4, the go to the downloaded
project's root directory:
{code %language=sh
{!$ cd <wsroot>
$ svn co <repo_url>/branches/sampleprj-0.4
cd sampleprj-0.4!}}
      }
      {operation
Enter the cppexe module directory
{code %language=sh
{!$ cd <wsroot>/sampleprj-0.4/cppexe!}}
      }
      {operation
Build and Run the sampleprj cppexe module:
{code %language=sh
{!$ make run!}}
      }
      {assert
{req abs.run.1}
The software is built and run. It's dummy output is printed on the console.
{code
{!Hello world from sampleprj::cpplib!
len=33
bufptr=b3820e60
[Text to be embedded as resource

]!}}
Note: the bufptr value can be different, it is a non predictible pointer value.
      }
      {operation
Start the debugger to run cppexe into:
{code %language=sh
{!$ make debug!}}
      }
      {assert
gdb is started
      }
      {operation
Start cppexe from the debugger:
{code %language=sh
{!(gdb) runapp!}}
      }
      {assert
{req abs.run.2}
cppexe is run, and returns to the debugger prompt when done.
      }
      {operation
exit the debugger
      }
      {operation
Jump to cpplib module and run unit tests
{code %language=sh
{!$ cd ../cpplib
$ make test!}}
      }
      {assert
{req abs.run.3}
Unit test are run and the test report is printed on the console. The sampleprj
is configure to have one test OK, and one test failing to be able to check error
detection and restitution in the report. The expected test summary is the
following:
{code
{!# ---------------------------------------------------------------------
# Successful tests
# ---------------------------------------------------------------------
- N4test11TestExampleE::testCaseSuccess 1.7083e-05 s (0.017083 ms).

# ---------------------------------------------------------------------
# Disabled tests
# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
# Failed tests
# ---------------------------------------------------------------------
- N4test11TestExampleE::testCaseFail    9.1389e-05 s (0.091389 ms).
test/TestExample.cpp:32
equality assertion failed
- Expected: 0
- Actual  : 1

# ---------------------------------------------------------------------
# Statistics
# ---------------------------------------------------------------------
- Tests: 2
- Total Failures: 1
- Total Errors: 0
- Total Disabled: 0
- Total time: 0.000108472 s (0.108472 ms)!}}
Of course, the exact timings may be different.
      }
      {operation
Start the debugger to run the tests:
{code %language=sh
{!$ make debugtest!}}
      }
      {assert
gdb is started
      }
      {operation
Run the tests from the debugger:
{code %language=sh
{!(gdb) runtests!}}
      }
      {assert
{req abs.run.4}
Tests are run as previously (but the final summary is not displayed) and returns
to the debugger prompt when done.
      }
      {operation
Exit the debugger, the test is completed.
      }
    }
  }
}
{section %title=User guide %xref=SecUM
  {section %title=Project layout
    {section %title=Project level file hierarchy
Buildscripts expects one specific files and directories layout to be able to
apply its generic rules and perform all needed actions to achieve to build
according the current project state. The standard layout is:
  - {kw <project name>-X.Y/}: root directory for the project's X.Y branch
    workspace.
    - {kw _doc/}: documentation module
    - {kw <1st module name>/}: 1st module directory. 
    - {kw <2nd module name>/}: 2nd module directory. 
    - ...
    - {kw <Nth module name>/}: Nth module directory. 
    - {kw app.cfg}: project configuration file
    - {kw Makefile}: project's root makefile, copy of the {a %href=http://www.eduvax.net/dist/noarch/abs-3.0-bootstrap.mk %%ABS bootstrap makefile}.
    - {kw build/}: root directory for all generated artifacts during the build
      process. Shall not be inserted into the version control system.
    - {kw local.cfg}: optional workspace local configuration file. Shall not be
      inserted into the version control system.
    }
    {section %title=Project configuration file app.cfg
This file hosts the application wide parameters. The mandatory definitions are:
  - {kw APPNAME=<application name>}: name of the application. Caution: since
    this name is used to define some output files names, it shall not contain
    any space, the '-' character or any special characters that may not be
    supported in a file name.
  - {kw VERSION=X.Y.Z}: version identifier. Must be initialized manually on
    project creation consistently with branch name set in the version control
    system. Then it is automatically maintained when branches are created from
    existing branch and when a branch is tagged. 
  - {kw ABS_REPO:=<URL>}: URL of the abs distribution repository.
  - {kw VABS:=X.Y}: version of ABS to be used to build the application.

The optionals definitions are:
  - {kw COMPANY=<company name>}: the name of the company or organization that
    owns the project.
  - {kw COPYRIGHT=<copyright declaration>}: Copyright information. The standard
    format is the following: {kw (c) <create date>[-<update date>] <copyright older name>}
  - {kw EXPMOD=<mod name>*}: list of modules to be exported. Any module that is
    a library to be used by another application should be exported.
  - {kw DOMAIN=<reversed domain name>}: Java package name prefix.
  - {kw USELIB=<<libname>-X.Y.Z>*}: list of external libraries directly used by
    the project.
  - {kw extra_import_defs=<any makefile content>}: additional rules and macro
    definitions to be inserted into the {kw import.mk} file packaged with the
    product. This {kw import.mk} file is included in any user application that,
    through its own cnofiguration and {kw USELIB} value, makes reference to the
    product.

    }
    {section %title=Module level file hierarchy
The internal file layout in modules is:
  - {kw <module name>}
    - {kw include/<project name>/<module name>}: public C/C++ header files
    - {kw src/}: implementation source files.
    - {kw test/}: unit tests source code.
    - {kw module.cfg}: module's configuration file.
    - {kw Makefile}: module's local makefile, copy of the {a %href=http://www.eduvax.net/dist/noarch/abs-3.0-bootstrap.mk %%ABS bootstrap makefile}.
    }
    {section %title=Module configuration file module.cfg
This file stores all the module specific configuration. The mandatory expected
definition are:
  - {kw MODNAME=<module name>}: the module's name. String without any special
    character is preferred, since this name will compose file names.
  - {kw MODTYPE=<module type>}: the module's type. Use any of the following 
    value
    - {kw exe}: "native" (C/C++) executable.
    - {kw library}: "native" (C/C++) library.
    - {kw jar}: java package
    - {kw python}: python package
    - {kw linuxmodule}: linux kernel module
    - {kw doc}: document set.

Additional definitions may be used:
  - {kw USEMOD=<module name>*}: list of modules from the same project that are
    used by the current module.
  - {kw LINKLIB=<lib name>*}: list of libraries to link with. Use short library
    name, that is, if {kw abc} is given, the expected shared object file name is 
    {kw libabc.so} for Unix/Posix systems, or {kw abc.dll} for Windows systems.
  - {kw USEJAR=<pacakge name>*}: list of java package needed by the current
    module (when module is itself a java package). Use only package/version
    name, that is if {kw abc-1.2.10} is set, the file named {kw abc-1.2.10.jar}
    is included in the {em CLASSPATH}.
  - {kw CFLAGS+=<CC argument>*}: additional C/C++ compiler flags.
  - {kw LDFLAGS+=<LD argument>*}: additional linker flags.
  - {kw MAINCLASS=<class name>}: name of the class to be used as the main entry
    point class in a java package. This class must have a public static method
    named {kw main} and expecting one string array as parameter.

{note %title=Anonymous module
When a module's name is equal to its project's name, it is considered as the
default anonymous module. The only differences between the anonymous default
module and any other module is the naming schemes:
{table %title=Naming schemes
 {tr
  {th Naming type} {th regular module} {th anonymous module}
 }
{?table %fields=th,td,td
Executable target file (unix) % bin/<app>_<module> % bin/<app>
Executable target file (windows) % bin/<app>_<module>.exe % bin/<app>.exe
Library (unix) % lib/lib<app>_<module>.so % lib/lib<app>.so
Library (windows) % bin/<app>_<module>.dll % bin/<app>.dll
Include dir % include/<app>/<module> % include/<app>
java package name % <domain>.<app>.<module> % <domain>.<app>
C++ namespace % <app>::<module> % <app>
}
}
There is no obligation to create a anonymous module for a project. But a project
can't have more than one anonymous module. Since all modules shall have distinct
name, it is not possible to have two modules having the same name than the
project.
}
    }
    {section %title=linux kernel modules
Buildscripts can handle the compilation of linux kernel modules. To integrate an
existing linux kernel module source code in an ABS managed project, apply
following steps:
  - create a new buidlscript module in the project using {km _lkm} as name
    suffix:
    {code %language=sh
{!make newmode M=<driver name>_lkm!}} 
  - Edit module.cfg file to define it is a linux kernel module:
    {code %language=sh
{!MODTYPE=linuxmodule!}}
  - Copy all source files (including root directory containing original
    makefile) int src dir.
  - When some imported source file should not be compiled (sometimes, obsolete
    files are remaining in public source code distributions of kernel modules),
    filter out those files by defining the {kw DISABLE_SRC} variable (do not
    include {kw src/} in listed file names).
    {code %language=sh
{!DISABLE_SRC=file1.c file2.c ... fileN.c!}}
  - The header files to be included from user space applications or from other
    kernel modules will be published in {kw include/<app>/<module>} directory
    only when explicitely listed in {kw module.cfg} using the variable 
    {kw PUB_H}. Specify file path from the {kw src} directory (do not include 
    {kw src/} itself.
    {code %language=sh
{!PUB_H=header1.h header2.h ... headerN.h!}}

The project's neighbour modules that need to include some of a kernel module
header shall use {kw USELKMOD} variable instead of {km USEMOD} because the
dependency reference expansion to compiler and linker flags is not exactly the
same for linux kernel modules and other modules.
    }
  }
  {section %title=ABS integration to a project
    {section %title=Integrate the make directory 
Buildscripts is just a set of makefiles, scripts and style sheets. There is no
binary to install, the only task is to include in the root directory, the ABS
bootstrap makefile as {kw Makefile}, and define the project's configuration
file.
    }
    {section %title=Reference ABS versions 
All packaged ABS version are available from the {a %href=http://www.eduvax.net/dist %%ABS distributions repository}.
Some mirror may have been created in other location that can't reach this public
primary repository, check people that have provided you this document that may
know about such mirror. This document first public issue as written while
integration ABS version 3.0.
    }
    {section %title=Create the configuration files and bootstrap makefiles.
From the project root (where the make directory of ABS has been integrated):
  - create {kw app.cfg} file and define at least the {kw APPNAME}, {kw VERSION},
    {kw VABS} and {kw ABS_REPO} variables.
  - extract the file core/bootstrap.mk from the ABS core distribution archive
    (or fetch the reference version such as {a %href=http://www.eduvax.net/dist/noarch/abs-3.0-bootstrap.mk %%abs-3.0-bootstrap.mk})
    into the project root directory and rename it {kw Makefile}.
  - when some modules are already existing, for each one go to its directory,
    then:
    - create {kw module.cfg} file en define at least the {kw MODNAME} and 
      {kw MODTYPE} variables.
    - copy the bootstrap makefile already integrated to the root directory as 
      the module's {kw Makefile} file.

After that you are ready to build your project with ABS by calling {kw make},
and even create new modules by calling {kw make newmod M=<module name>}. Next
sections details all services available through make targets and variables that
can be used to configure your project and enclosed modules.
    } 
  }
  {section %title=Make targets
Buildscripts services and function are available as make targets. User can
operate from project root to work with the whole project or at module level when
focusing on a particular module.
    {section %title=At project level
The project level main targets are:
  - {kw make all}: default target, builds all modules, without unit tests.
  - {kw make testbuild}: builds all modules including unit tests but without
    running the tests.
  - {kw make clean}: deletes all built artifacts (deletes the {kw build} and 
    {kw dist} directories.
  - {kw make newmod M=<module name>}: creates a new module. Create the directory
    structure, {kw module.cfg} and {kw Makefile} files with default minimal
    configuration (default module type is {em library}).
  - {kw make branch}: creates new branch from the current one. New branch
    identifier (X.Y) and comment including issue reference will be interactively
    requested during processing. Write access to the subversion repository is
    needed to proceed.
  - {kw make dist}: builds distribuable binary "short" package. Such packaging
    is design to support publication to a build repository. The packages
    available on the build repository can be fetched by any project (see 
    {kw USELIB} variable usage).
  - {kw make help}: in-line help system. Show usage information about
    application level services.
  - {kw make doc}: generate documentation from code. Doxygen is needed to
    process the source code and shall be available on your workstation to use
    this feature.
  - {kw make install [PREFIX=<install root>]}: builds and installs the
    application. The default installation root is {kw /opt/<app name>-<version>}.
    All needed dependencies are also installed, so avoid using {kw /usr} or 
    {kw /usr/local} as installation root to avoid any risk to overwrite some
    system libraries.
  - {kw make distinstall}: generates an installation archive including the
    complete built application and its dependencies. The generated file is
    executable and handles, when later run, the installation process.
     - when project contains in its root directory a file named 
       {kw extradist.sh}, this script is run during the processing of the dist 
       target. It receive the target build path (default is {kw dist/<app>-<version>}
       as first argument. You can put in this script any commands that 
       copy/create/update files into the dist directory that will then be
       included in the built final archive file.
     - using the extra dist feature, one can insert in the {kw dist/<app>-<version>/bin}
       directory a file named {kw postinstall.sh}. The in installation archive
       embedded script, at the end of the install process, looks at this file
       availability and if present run it with two arguments, the application
       name, and the application version. Caution: take care to set this 
       {kw postinstall.sh} file the executable attribute in order to be invoked
       by the installation script.

Some utility and additional targets may be added according to ABS improvements.
See in-line help for more complete reference.
    }
    {section %title=At module level
The module level main targets are:
  - {kw make all}: default target, builds the module. The build of other modules
    may be automatically triggered regarding the prerequisites definition 
    (see {kw USEMOD} variable).
  - {kw make run [RUNARGS="[<arg>]*"]}: builds and run the module. Applicable to
    executable modules or libraries found to include a lua_open function. 
    In this second particular case, ABS attempts to launch the module from a lua
    shell and requires some feature from mastol. This target also ensure library
    search paths are consistent with dependencies definitions.
  - {kw make testbuild}: builds the module and its unit tests but doesn't run 
    the tests.
  - {kw make check [RUNARGS="+|-f <test name pattern>"]}: builds the module and
    its unit tests, then run the tests.
    {note %title=Test naming
Cppunit that is used as the unit test engine for C/C++ modules, can use the
symbol names as test identifier. To capture the symbol name, run once 
{kw make check} and see the right names to use to identify test on the test
execution report.
{code
{!$ make check
[...]
# ------------------------------------
# Successful tests
# ------------------------------------
- N4test11TestExampleE::testCaseSuccess 1.4995e-05 s (0.014995 ms).
[...]
$ make check RUNARGS="+f N4test11TestExampleE"
[...] only test from TestExample test class are done.
$ make check RUNARGS="-f testCaseSuccess"
[...] all test are done except methods named testCaseSuccess (whatever is the enclosing test class)!}}
}
  - {kw make debug}: same as {kw make run} but inside a {em gdb} session. Once
    {kw gdb} shell is ready, invoke {kw runapp} to start running the module in 
    the debugger.
  - {kw make debugcheck}: same as {kw make check} but inside a {em gdb} session.
    Once {kw gdb} shell is ready, invoke {kw runtests} to start running the
    tests in the debugger.
  - {kw make test}: see {kw make check}
  - {kw make debugtest}: see {kw make debugcheck}
  - {kw make edebug}: displays parameters required for debugging from 
    {em Eclipse} (applicable to executable modules only). 
  - {kw make edebugtest}: displays parameters required for debugging unit tests
    from {em Eclipse}.
  - {kw make newclass C=<class name>}: generate new empty class files (both
    implementation and headers for C++) complient to ABS rules.
  - {kw make newtest T=<name of class to test>}: create source code file for a
    unit testing class. 
  - {kw make help}: in-line help system. Show usage information about per module
    available services.

Some utility targets may be added according to ABS improvements. See in-line
help for more complete reference.
    }
    {section %title=Options
the main build targets will use the following option (given as make command
arguments) to specialize the build process:
  - {kw MODE=<debug|release>}: compilation mode, with debug symbol and tracing
    activated or without debug symbol, tracing deactivated and some optimization
    flags. The default mode is {em debug}.
  - {kw DEFINES="<symbol1> <symbol2> ..."}: C/C++ preprocessor symbol 
    definition. Implementation can provide alternate or special optional
    features and this argument enable the user to activate such. Any symbols
    provided in the list should match at least one {kw #ifdef} directive in
    C/C++ source code. 
    }
    {section %title=distribution archive and deployment
Official distributable packages should be built and published by the continuous
integration system that includes many automated checks. However manual build of
such package is possible through make targets (and the automated system use the
same targets). The operations to be performed for the two step build and publish
process are:
  - use command {kw make dist} or {kw make distinstall} regarding the product
    is only a library or includes applications.
  - copy the generated archive in {kw dist} to your web server hosting your
    binaries repository: 
    {code %language=sh
{!scp dist/<product>-<version>.<arch>.tar.gz <login>@<webserver>:<DocumentRoot>/dist/<arch>!}}
    {note %title=Build and publish for every architecture
This process shall be repeated for every supported architecture, that is, build
the package on every compilation host required to cover all the needed processor
classes and Operating Systems.

To meet traceability requirements, only fresh checkout of tagged version of
a product should be build and published to the repository. The continuous
integration state is available through its {a %href=https://sdengrle.public.infrapub.fr.st.space.corp/jenkins/view/ASTRE/ %%web interface}.
}
    {note %title=Binaries identification.
Buildscripts includes in the C/C++ binaries an identification string. The 
{kw ident} command can parse the binary to retrieve that string and restore the
build and configuration context.
{code %language=sh
{!$ ident mastol_luad
mastol_luad:
     $Attr: app.name=mastol $
     $Attr: app.version=1.1.10 $
     $Attr: app.revision=5817. $
     $Attr: app.file=mastol_luad $
     $Attr: company=Airbus Defence and Space $
     $Attr: copyright=(c) 2013-2017 Airbus Safran Launchers $
     $Attr: build.mode=release $
     $Attr: build.opts= $
     $Attr: build.date=mer. mai 10 10:10:21 CEST 2017 $
     $Attr: build.host=apollo $
     $Attr: build.user=m026258 $
     $Attr: build.id=null $!}} 

Some criteria to know the binary was produced through the validated process by
continuous integration system are:
  - version has no {kw d} suffix.
  - revision has no {kw M} suffix.
  - build mode is {kw release}
  - build identifier is not null.

Only tagged software should deployed onto integration, validation or production
target hosts.
}
    }
    {section %title=Workspace local configuration
Aside the application configuration file {kw app.cfg}, some workspace local
parameter definitions can be stored in a file named {kw local.cfg}. This file is
dedicated to the handling or workaround of local workspace issues, such as using
alternate binary repository. Please never add this file into the revision
control system since it can overload the correct shared project configuration
with values not applicable to every reference compilation hosts. Here are some
examples of use:
{code %title=local.cfg - add local mirror to the binary repository search paths %language=make 
{!LIB_REPO:=/the/local/path,$(LIB_REPO)!}}
{code %title=local.cfg - force architecture name %language=make 
{!ARCH=RedHatEnterpriseWorkstation_6.3_x86_64!}}
    }
  }
  {section %title=Dependencies management
    {section %title=Sample projects
Let's have two applications:
  - {kw avionic} inluding the mandatory module {kw bus} and the optional
    modules {kw alpha} and {kw beta}. Other dependencies are:
    - All modules need the external library {kw space-0.2.5}
    - {kw beta} needs {kw alpha}
    - and {kw beta} also uses another external library {kw star-1.0.0}
  - {kw spaceship} is an application using version 1.1.0 of {kw avionic} and has
    itself two modules:
    - {kw payload} using only {kw bus} from {kw avionic}
    - {kw booster} using optional module {kw beta} from {kw avionic}.
    }
    {section %title=Step 1 - define applications overall dependencies
To link an application to external libraries, define the USELIB macro int the
application configuration file {kw app.cfg}
{code %title=avionic/app.cfg %language=make
{!APPNAME=avionic
VERSION=1.1.0
USELIB=space-0.2.5 star-1.0.0!}}
{code %title=spaceship/app.cfg %language=make
{!APPNAME=spaceship
VERSION=1.1.0
USELIB=avionic-1.0.0!}}

{note %title=On version identifiers
Software components versions managed with ABS should be defined by three numbers
and the software product full name format is {kw <name>-X.Y.Z}. Using this full
specification allows to define dependencies without any ambiguity. But regarding
the current project's maturity, such strict definition may be too disturbing
since, during some period, versions can change frequently. Moreover, only tagged
version are available through such definition and some recent needed updates may
not be available through tags yet. To ease in development version definition,
the two following kind of version reference can be used:
  - {kw <name>-X.Y}: will bring the last tagged version of the component in
    branch X.Y. The downloaded content will then be different after each new tag
    in branch {kw <name>-X.Y}.
  - {kw <name>-X.Y.Zd}: will bring the last build made by continuous integration
    system before tagging {kw <name>-X.Y.Z}.

Caution: the {kw d} suffix shall never be used in a product to be tagged. An
application for which controlled state and configuration are expected can't
refer to any "moving" dependency.
}
    }
    {section %title=Step 2 - make reusable modules public
The module of an application to be reused by some other applications (typically
the libraries) shall be explicitly declared to ensure the header files and other
needed meta information are included in the published final package. Use the 
{kw EXPMOD} macro to list all the modules to be exported.
{code %title=avionic/app.cfg %language=make
{!APPNAME=avionic
VERSION=1.1.0
USELIB=space-0.2.5 star-1.0.0
EXPMOD=bus alpha beta!}}
    }
    {section %title=Step 3 - explicit for each module the local dependencies
Locally at the module level, all dependencies shall be defined: {kw USEMOD}
lists the other modules of the same application that are used by the current
module. {kw LINKLIB} lists the few external shared objects brought by external
dependencies that the current module directly use.

For the three {kw avionic}'s modules:
{code %title=avionic/bus/module.cfg %language=make
{!MODNAME=bus
MODTYPE=library
LINKLIB=space!}}
{code %title=avionic/alpha/module.cfg %language=make
{!MODNAME=alpha
MODTYPE=library
LINKLIB=space!}}
{code %title=avionic/beta/module.cfg %language=make
{!MODNAME=beta
MODTYPE=library
USEMOD=alpha
LINKLIB=space star!}}

Then for the two {kw spaceship}'s modules:
{code %title=spaceship/payload/module.cfg %language=make
{!MODNAME=payload
MODTYPE=library
LINKLIB=avionic_bus!}}
{code %title=spaceship/booster/module.cfg %language=make
{!MODNAME=booster
MODTYPE=library
LINKLIB=avionic_beta!}}
    }
    {section %title=Dependencies check %xref=SecDepCheck
However, despite any effort to follow the rules presented above, dependencie
management can become far complex. Since a project defines only its direct
dependencies, it can't ensure any used external library will not itself use
a library also linked directly to the project but with a different version. To
support the user and at least identify the library mix issues, some checks are
performed on the full {kw USELIB} defintion recursively computed from include to
include. A warning is displayed during the build when different versions of
a same lib is found. Invoking {kw make checkdep} displays a complete depedency
graph.
{fig %title=Real world example of a dependency graph with a version conflict %src=checkdep.png}
    }
  }
  {section %title=Documentation module
    {section %title=Extend documentation templates
ABS Doc module permit the use of additional templates to generate documentation
files. This is done using an absext module (see section {xref absext} ).

{note 
no need {kw ABS_EXT_MAP} variable in {kw module.cfg}, just include the
{kw main.mk} file in {kw app.mk} to forward the inclusion in the generated 
{kw import.mk} file that is included in the distribution package:
{code %language=make
{!extra_import_defs=include $$(_absext_index_<project name>_<module name>)/main.mk!}}
}
In src/main.mk, add the path to the abs ext (_absext_index_<project name>_<module name>)
in TEXINPUTS variable and add couple in HEMLTOTEX_MAP.
            
To use the new template, just import the generated project using USELIB variable
in {kw app.cfg}. Use the DEFAULT_TEMPLATE variable to indicates the name of the
template to use for the generation of the documentation.
        
      {section %title=Example of extension module
Module 'extmodexample' hierarchy in prjexample project:
  - prjexample
    - app.cfg
    - Makefile
    - extmodexample
      - module.cfg
      - src
        - main.mk
	- styleExt.tex.xsl
	- styleExt.xhtml.xsl
	- styleExt.xml.xsl
	- module.cfg
      - Makefile
                    
{code %title=content of app.cfg %language=make
{!APPNAME=prjexample			
extra_import_defs=\
include $$(_absext_index_prjexample_extmodexample)/main.mk # this permit to load the main.mk at the load of external libraries.!}}
	
{code %title=content of module.cfg %language=make
{!MODNAME=extmodexample
MODTYPE=absext!}}
			
{code %title=minimal content of styleExt.*.xsl %language=xml
{!<?xml version="1.0" encoding="iso-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:import href="style.tex.xsl"/> <!-- import the default style (in abs doc module) -->
</xsl:stylesheet>!}}
			
{code %title=content of main.mk %language=make
{!TEXINPUTS+=$(_absext_index_prjexample_extmodexample)//
HEMLTOTEX_MAP+=<template name>:$(_absext_index_prjexample_extmodexample)/styleExt.tex.xsl
HEMLTOXHTML_MAP+=<template name>:$(_absext_index_prjexample_extmodexample)/styleExt.xhtml.xsl
HEMLTOXML_MAP+=<template name>:$(_absext_index_prjexample_extmodexample)/styleExt.xml.xsl!}}
        }
        
        {section %title=Example of use in a _doc module
To use the extension, simply add the library in USELIB in app.cfg and add
following varibles in the module.cfg.
{table %title=Variables in module.cfg
 {tr
  {th %w=1 %%Variable} {th %w=4 %%Description}
 }
{?table
DEFAULT_TEMPLATE % The name of the template to use for all the heml docs in module
TEMPLATE % Permit to specify a template for a specific heml file (the value is a list of <filename without extension>:<template name>)
}
}
        }
    }
  }
  {section %title=Variables references %xref=SecVarIndex
Any of the following variable referred and used by the various included
makefiles can be overloaded (new definition using {kw =} or {kw :=} operators)
into any configuration file: {kw app.cfg}, {kw local.cfg} or {kw module.cfg},
loaded in that order. Take care of the load order to ensure you get the expected
value definition for each module in each workspace.

All variables can also be overloaded through the command line. The values set in
command line take precedence over any other definition.
{table %title=Variable index and reference
{tr
{th %w=1 %%Variable}{th %w=1 %%Default value}{th %w=2 %%Description, role and usage}
}
{?table
ABS_REPO % % URL of the distribution repository to use to fetch ABS.
APPNAME % % Application name
ARCH % $(SYSNAME)_$(HWNAME) % Target's architecture name. Without other overloading, it shall reflect the real architecture of the current compilation host.
CC % gcc % C compiler command.
CFLAGS % -Iinclude -fPIC % C compilation options. Caution: strict overload may suppress all additions performed by the dependencies management from USELIB and USEMOD definitions.
COMPANY	% % Company name.
COPYRIGHT % % Copyright info, usage is to follow this format: (c) <creation year>-[<publication year>] <company name> 	 	
CPPC % g++ % C++ compiler command.
DEFINES	% % Extra C preprocessor symbols to define: each word contain by this variable is forwarded to the C/C++ compiler through CFLAGS as -D<symbol>
DOMAIN % % Package name prefix pour java applications.
EXPMOD % % List of public modules, that is the list of modules that are libraries with C/C++ header to be included in the distribution packages.
EXTLIBDIR % $(TRDIR)/extlib.$(ARCH) % Directory to host local copies of externals libraries.
JAR % jar % Java packager command
JAVA % java % Java run-time command
JAVAC % javac % Java compiler
JDB % jdb % Java debugger command
HWNAME % output of uname -m % CPU architecture name (such as x86_64, i686, ...)
LD % g++ % Linker command.
LDFLAGS % % Linker arguments. Caution: strict overload may suppress all additions performed by the dependencies management from USELIB, USEMOD and LINKLIB definitions.
LIB_REPO % $(ABS_REPO) % Pre-built package of external libs repository URL. May contain several location (',' is the separator character). Do not include file:// for local file systems locations.	
MAINCLASS % % Main class name for a java module.
MMARGS % % Make command arguments to be forwarded from the application level global make to the modules' make. May be used to request multi-threaded compilation (see make documentation about -j option).
MODE % debug % Compilation mode, two values accepted: debug or release. Using first binaries are compiled without optimization and with debug symbols, while second requests application of some optimisation and no debug symbols.	
MODNAME % % Module's name
MODULES	% <computed modules list> % List of module to build from the application level make. Defaultly this variable is set automatically by searching available makefiles in the project's subdirectories.
MODTYPE	% % Type of module, one of the following: jar (java package), library (C/C++ shared object), exe (C/C++ command), linuxmodule (linux kernel module), doc (document set), python (python library). 	
OBJDIR % $(TRDIR)/obj/$(MODNAME) % Directory to store intermediate files during the build process (includes object files, generated source code).
PREFIX % /opt/$(APPNAME)_$(VERSION) % Default installation dir prefix for the install make target.
PUB_H % % List of C/C++ header files stored in src directory to be published. Note: ABS standard layout request to store such files in include directory aside src directory. This feature was introduced only to ease the integration of legacy non compliant code into an ABS project.	 	
RMODDEP % 1 % Maximum recursion level for deep inter module dependencies checking.
RUNARGS % % Arguments to be forwarded to the application execution when invoking make run, make debug, make check or make debugcheck.
SYSNAME % output of make/OS.sh % Target operating system. May include a version number (ex: Debian_8, CentOS_7)
TRDIR %	$(PRJROOT)/build/$(MODE).$(ARCH) % Root directory for any built artifact storage.
USEJAR % % List of external dependencies for a java package. Similar to USELIB but dedicated to java. For each entry, the package is downloaded from  $(LIB_REPO)/noarch/<entry name>.jar
USEJMOD % % List of internal dependencies for a java package. Similar to USEMOD but dedicated to java.
USELIB % % List of external dependencies. For each entry, the package is downloaded from $(LIB_REPO)/$(ARCH)/<entry name>.tar.gz
USELKMOD % % List of internal dependencies towards linux kernel modules.
USEMOD % % List of internal dependencies.
VABS % % ABS version to use.
VERSION % % Application version. Version number defines the current development increment. The value is finally the next tag name for the current branch.
VISSUE % % Number of the Jira issue used to track the current branch activity. Used for release note processing.
VPARENT % % Parent version number. The version used to create the branch of the current version, or the previously released version in the same branch. Used for release note processing.
}
}
  }
}
{section %title=Requirement references
  {index %type=req}
}
}
